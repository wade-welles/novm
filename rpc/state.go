package control

import (
	kvm "github.com/multiverse-os/portalgun/vm/kvm"
)

//
// State.
type State struct {
	// Our device state.
	// Note that we only encode state associated with
	// specific devices. The model type is a generic wrapped
	// around devices which *may* encode additional state,
	// but all the state associated with the model should be
	// regenerated on startup.
	Devices []DeviceInfo `json:"devices,omitempty"`

	// Our vcpu state.
	// Similarly, this should encode all the state associated
	// with the underlying VM. If we have other internal kvm
	// devices (such as APICs or PITs) then these should be somehow
	// encoded as generic devices.
	VCPUs []kvm.VCPUInfo `json:"vcpus,omitempty"`
}

func SaveState(vm *kvm.VirtualMachine, model *Model) (State, error) {
	// Pause the vm.
	// NOTE: Our model will also be stopped automatically
	// with model.DeviceInfo() below, but we manually pause
	// the Vcpus here in order to ensure they are completely
	// stopped prior to saving all device state.
	err := vm.Pause(false)
	if err != nil {
		return State{}, err
	}
	defer vm.Unpause(false)

	// Grab our vcpu states.
	vCPUs, err := vm.VCPUInfo()
	if err != nil {
		return State{}, err
	}
	// Grab our devices.
	// NOTE: This should block until devices have
	// actually quiesed (finished processing outstanding
	// requests generated by the VCPUs).
	devices, err := model.DeviceInfo(vm)
	if err != nil {
		return State{}, err
	}
	// Done.
	return State{VCPUs: vCPUs, Devices: devices}, nil
}
